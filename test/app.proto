gstate = {init=0, s1=1, s2=2, s3=3, s4=4, s5=5, s6=6, s7=7, s8=8, final=9}
--lde引擎是顺序匹配，顺序由proto_list决定
proto_list={"test", "ppstream", "qqlive", "http", "dns", "ssl", "nat",
			"sametime", "qq_file", "ssh", "ftp", "ftp_pd", "ftp_ad"}
engine_list={"pde", "sde", "lde"}
analysis_engine_list = {"ccde"}
pkb_dir = {up=1, down=2}

sde={}
sde.conf = {
                {"0~7", "-8~-1"},--第一个图的范围为0~7以及-8~-1
                --all必须放在最后一个
                {"all"},
           }

--下面的是一个实例协议
--[[demo_proto = {}
    demo_proto.pde="udp/8000,tcp/8000,tcp/14000" -- pde是端口规则，多个规则是并的关系，只要满足一个即可
    demo_proto.sde={                             -- sde是字符规则，由索引和值两部分组成，索引需要用引号括起来，索引范围用~连接，\
                                                    有多种可能性用|分隔开来，值需要用引号括起来，默认是16进制，不需要写0x，如果 \
                                                    是字符串可以用括号括起来，如"0203(windslinux)",可以混用，sde内容也可以是有多种可能性，\
                                                    各种可能性之间用|分割开，分割线的前后是上一段的结束和下一段的开始
                    {["0"]="fe", ["3~5|-5~-1"]="0304|05fe|abcd"}, --索引为0值为fe，并且（一个花括号内的多个索引值为与的关系）\
                                                            索引3~5之间或者-5~-1（最后一个字节）之间有序列为:030405fe
                    {["0"]="fd", ["2~4"]=3456},           --或者（多个花括号之间是或的关系）索引为0的值为fe，并且索引2~4之间的序列为3456
                }
    demo_proto.lde = function(buf, session)
			  local state = gstate.init
			  if (buf:len() > 2) then
			  if (buf(1,2):uintle() == buf:len() + 2) then
			      state = gstate.final
			  end
			  end
			  return state
			  end
]]

test = {}
test.pde = "udp/8000"
test.sde = {
                {["0"]="fe", ["2-3|1~5"]="42000042|(zhou)"}
            }

qq_file = {}
qq_file.lde = function(buf, session)
			  local state = session:state()
			  if (buf:len() >= 2) then
			  if (state == gstate.init and buf:getbyte(0) == 0x04 and buf:getbyte(-1) == 0x03) then
				  if (buf:dir() == pkb_dir.up) then
				  	 session:saveindex(1, 2)
				  	 state = gstate.s1
				  end
				  return state
			  end
			  end

			  if (state == gstate.s1 and buf:dir() == pkb_dir.down) then
			     if (buf(1,2):uintbe() == session:loadnum()) then
				 	state = gstate.final
				 end
			  end
			  return state
			  end

ppstream = {}
ppstream.lde = function(buf, session)
			   local state
			   local len = buf:len()
			   -- ppstream head length is 4
			   if (len >= 4) then
			   	   local buf_hd = buf(0,2):uintle()
				   if (buf:getbyte(2) == 0x43 and buf:getbyte(3) == 0 and
				   	   (buf_hd == len or buf_hd == (len-4))) then
				       state = gstate.final
				   end
			   end
			   return state
			   end

qqlive = {}
qqlive.lde = function(buf, session)
			  	 local state = gstate.init
				 -- ppsteam head length is 4
				     if (buf:len() >= 5) then
					 local val1 = buf(1,2):uintle()
					 local val2 = buf(3,2):uintbe()
				     if (buf:getbyte(0) == 0xfe and val1 == buf:len()-3 and
				         val1 == val2) then
				         state = gstate.final
			      	 end
				 end
				 return state
				 end

nat = {}
nat.lde = function(buf, sesison)
		      local state
		      if (buf:len() >= 4) then
		      if (buf(0,4):uintbe() == 0x00010008) then
		          state = gstate.final
		      end
	          end
		  return state
		  end

http = {}
http.pde = "tcp/80"

dns = {}
dns.pde = "udp/53"

ssl = {}
ssl.pde = "tcp/443"

sametime = {}
sametime.pde = "tcp/1533"

ssh = {}
ssh.pde = "tcp/22"

ftp = {}
ftp.pde = "tcp/21"
ftp.cdde =  {
                if (buf(0, 4).string() == "PORT") then
            }

--print(qq_talk.sde[1][-1])
--[[for k, v in pairs(qq_chat)
do
print(k,v)
end]]
